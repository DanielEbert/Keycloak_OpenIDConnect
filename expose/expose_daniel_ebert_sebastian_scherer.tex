\documentclass[12pt]{article}

\parindent0ex
\parskip 1ex plus 0.4ex minus 0.4ex

\usepackage[a4paper,vmargin=30mm,hmargin=25mm]{geometry}
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{german}


\usepackage{csquotes}
\usepackage[colorlinks=true,linkcolor=red]{hyperref}

\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}

\usepackage[backend=biber]{biblatex}
\bibliography{literatur}

\title{Single Sign On bei Webanwendungen}
\author{Daniel Ebert \\
	Sebastian Scherer}
\date{\today}


\begin{document}
\maketitle
	
\section{Grundlagen}
Dem Titel nach beschäftigt sich unsere Arbeit mit Single Sign On (SSO) für Webanwendungen.
Ziel des SSO-Mechanismus ist es, dass sich Benutzer nur einmal unter Zuhilfenahme eines einzigen Authentifizierungsverfahrens identifizieren muss.
Danach übernimmt der SSO-Mechanismus die Aufgabe, den Anwender zu authentifizieren und die erkannte Identität zu bestätigen. Dies hat den Vorteil, dass sich der Benutzer sich nur einmal identifizieren muss und seine Identität an weitere Systeme weitergegeben werden kann, ohne dass sich dieser erneut anmelden muss.
Die folgenden Untersektionen beinhalten unsere vorläufige Gliederung.

\subsection{Einführung}	
Einleitendes Kapitel in das Thema SSO, welches die Definition des Mechanismus enthält und erläutern die Use-Cases für SSO bei Webanwendungen. SSO ist für die Sicherheit eine Methode um die Psychological Acceptability der Benutzer zu erhöhen, da sie nicht dazu gezwungen werden sich jedesmal manuell zu authentifizieren.

User sind Entitäten, die in der Lage sind, sich in das Keycloak System einzuloggen. Clients sind Entitäten, die Keycloak zur Authentifizierung eines Benutzers beauftragen können. Clients stellen Ressourcen zur Verfügung, deren Zugriff auf die authentifizierten und autorisierten User beschränkt ist. In Keycloak erhalten User nach einem erfolgreichen Log-In einen Token. User können sich mit diesem Token bei mehreren Clients authentifizieren, ohne sich erneut z.B. mit E-Mail und Passwort einloggen zu müssen. Tokens sind von Keycloak signiert und können deshalb auf ihre Echtheit überprüft werden.
	
\subsection{Aufbau von SSO}	
Es gibt mehrere Möglichkeiten SSO umzusetzen. Da der Umfang der Ausarbeitung 20 Seiten betragen soll, ist es nicht möglich alle SSO-Architekturen vorzustellen. Unsere praktische Umsetzung basiert auf dem OpenID Connect (OIDC) Standardprotokoll für Autorisierung und Authentifizierung und daher werden wir diese Architektur vorstellen. Wir haben uns für OIDC entschieden, da dieses speziell für web applications entwickelt worden ist. [1]

\subsection{SSO-Threat Model}
	
In dieser Sektion wollen wir die gängigen Schwachstellen und die passenden Gegenmaßnahmen erläutern.
Die verbreitetsten Schwachstellen sind:
	
\begin{itemize}
	\item Complete Mediation
		
	\item Brute Force Angriffe auf Passwörter
		
	\item Clickjacking
	
		
	\item SSL/HTTPS Anforderungen
	
	\item CSRF Angriffe
	
	\item Kompromittierte Zugangstoken
	
	\item Open Redirectors
\end{itemize}

\subsection{Umsetzung von SSO innerhalb einer Beispielwebanwendung}
SSO soll an einer Beispielwebanwendung mit Keycloak gezeigt werden. Keycloak ist eine Open-Source-Lösung für Identity und Access Management (IAM), die auf die Entwicklung moderner Anwendungen und Services ausgerichtet ist. Die Community-Version von Red Hat macht es einfach, die Authentifizierung an Anwendungen und Diensten mit wenig bis gar keinem Code sicher zu implementieren. \cite{RFC6819}

Die Umsetzung basiert auf der oben gezeigten Architektur. Im praktischen Teil setzen wir einen Keycloak Server im Standalone Mode auf. Wir erstellen eine Single Page Application mit ReactJS, bei der sich User in Keycloak registrieren und einloggen können und Ressourcen von 2 Backend Systemen über eine REST API abrufen können. Die Backend Systeme sind in Python geschrieben und verwenden Flask. Diese Backend und Frontend Systeme werden in Keycloak angebunden und integriert. Dabei fokussieren wir uns auf die SSO Aspekte von Keycloak wie User Registration, User Login, User Logout, und Session Management. Keycloak Features die weniger mit SSO zu tun haben, wie z.B. Identity Brokering, Rollen und Gruppen, externe Datenbanken, und Log Events, werden nicht näher bearbeitet. Der Keycloak Server, als auch die Backend und Frontend Systeme laufen in getrennten Docker Containern. Wir verwenden Docker Compose um die Container hinsichtlich z.B. des Netwerks oder des persistenten Speichers hin zu konfigurieren.
	
	

% https://www.keycloak.org/documentation.html
% https://github.com/thomasdarimont/awesome-keycloak < verlinkt 100 weitere websiten die etwas mit keycloak zu tun haben
% https://developers.redhat.com/blog/2019/12/11/keycloak-core-concepts-of-open-source-identity-and-access-management/


	% keycloak server aufsetzen und konfigurieren
	% 1 sample reactjs single page app using keycloak as SSO
	% 2 backend services using python flask
	% integrate backend and frontend into keycloak
	% Was wir nicht machen: 
	%( Keycloak comes with its own embedded Java-based relational database called H2. for production keycloak recommends to use a more production ready external database but in our examples etc we will stick with the default embedded DB) check how much effort is integrating persistent DB
	% We use Standalone Mode, no distributed keycloak server instances
	% focus on SSO aspects, i.e. user registration, user login, user logout, different authentication flows; less focus on external USER DBs like kerberos, ldap; Identify Brokering (i.e. login via Google or github), log events
	
	
	
	
	
	%[1] https://www.keycloak.org/docs/latest/securing_apps/#openid-connect-vs-saml
	
	%* https://www.ei.ruhr-uni-bochum.de/media/ei/veroeffentlichungen/2017/01/30/oidc-security.pdf
	%* https://openid.net/specs/openid-connect-core-1_0.html
	%* https://github.com/keycloak/keycloak
	%* https://tools.ietf.org/html/rfc6819
	%* 
	
	
	


\nocite{234523453r67}
\nocite{4523452345}

\printbibliography


\end{document}
